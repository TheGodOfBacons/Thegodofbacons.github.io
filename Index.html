<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Car Driving Game - Three.js</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; height: 100%;
    background: #87ceeb;
    font-family: Arial, sans-serif;
  }
  #overlay {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.7);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2em;
    cursor: pointer;
    user-select: none;
    z-index: 10000;
  }
  canvas { display: block; }
</style>
</head>
<body>
<div id="overlay">Click to start driving</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/PointerLockControls.js"></script>

<script>
  let scene, camera, renderer;
  let car, wheels = [];
  let velocity = 0;
  let maxSpeed = 0.15;
  let acceleration = 0.002;
  let braking = 0.005;
  let friction = 0.001;
  let steeringAngle = 0;
  let maxSteering = 0.04;
  let steeringSpeed = 0.002;
  let moveForward = false, moveBackward = false, turnLeft = false, turnRight = false;
  let controlsLocked = false;

  const clock = new THREE.Clock();

  init();

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

    // Lights
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshPhongMaterial({color: 0x555555});
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Obstacles
    const obsGeo = new THREE.BoxGeometry(4, 4, 4);
    const obsMat = new THREE.MeshPhongMaterial({color: 0x880000});
    for(let i=0; i<20; i++) {
      let obs = new THREE.Mesh(obsGeo, obsMat);
      obs.position.set((Math.random()-0.5)*180, 2, (Math.random()-0.5)*180);
      obs.castShadow = true;
      scene.add(obs);
    }

    // Car chassis
    const chassisGeo = new THREE.BoxGeometry(4, 1.2, 8);
    const chassisMat = new THREE.MeshPhongMaterial({color: 0x0000ff});
    car = new THREE.Mesh(chassisGeo, chassisMat);
    car.castShadow = true;
    car.position.y = 1;
    scene.add(car);

    // Wheels (simple cylinders)
    const wheelGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.5, 16);
    const wheelMat = new THREE.MeshPhongMaterial({color: 0x222222});
    const wheelPositions = [
      [-1.5, 0.4, 3],  // Front left
      [1.5, 0.4, 3],   // Front right
      [-1.5, 0.4, -3], // Rear left
      [1.5, 0.4, -3],  // Rear right
    ];

    for(let pos of wheelPositions) {
      let wheel = new THREE.Mesh(wheelGeo, wheelMat);
      wheel.rotation.z = Math.PI/2;
      wheel.position.set(pos[0], pos[1], pos[2]);
      wheel.castShadow = true;
      car.add(wheel);
      wheels.push(wheel);
    }

    // Camera offset behind car
    camera.position.set(0, 5, -12);
    camera.lookAt(car.position);

    // Renderer
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Overlay & controls
    const overlay = document.getElementById('overlay');
    overlay.addEventListener('click', () => {
      if (!controlsLocked) {
        controlsLocked = true;
        overlay.style.display = 'none';
      }
    });

    // Controls
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    window.addEventListener('resize', onWindowResize);

    animate();
  }

  function onKeyDown(e) {
    switch(e.code) {
      case 'KeyW': moveForward = true; break;
      case 'KeyS': moveBackward = true; break;
      case 'KeyA': turnLeft = true; break;
      case 'KeyD': turnRight = true; break;
    }
  }

  function onKeyUp(e) {
    switch(e.code) {
      case 'KeyW': moveForward = false; break;
      case 'KeyS': moveBackward = false; break;
      case 'KeyA': turnLeft = false; break;
      case 'KeyD': turnRight = false; break;
    }
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);

    if(controlsLocked) {
      const delta = clock.getDelta();

      // Acceleration/braking
      if(moveForward) velocity += acceleration;
      else if(moveBackward) velocity -= braking;
      else {
        // friction slows car down when no input
        if(velocity > 0) velocity -= friction;
        else if(velocity < 0) velocity += friction;
      }

      // Clamp velocity
      if(velocity > maxSpeed) velocity = maxSpeed;
      if(velocity < -maxSpeed/2) velocity = -maxSpeed/2;

      // Steering
      if(turnLeft) steeringAngle += steeringSpeed;
      else if(turnRight) steeringAngle -= steeringSpeed;
      else {
        // Return steering to center gradually
        steeringAngle *= 0.9;
      }

      if(steeringAngle > maxSteering) steeringAngle = maxSteering;
      if(steeringAngle < -maxSteering) steeringAngle = -maxSteering;

      // Update car rotation and position
      car.rotation.y += steeringAngle * velocity * 5;  // Turning speed depends on velocity

      // Calculate forward vector
      const forward = new THREE.Vector3(
        Math.sin(car.rotation.y),
        0,
        Math.cos(car.rotation.y)
      );

      // Move car forward/backward
      car.position.add(forward.multiplyScalar(velocity));

      // Rotate front wheels according to steering angle
      wheels[0].rotation.y = steeringAngle * 5; // Front left wheel
      wheels[1].rotation.y = steeringAngle * 5; // Front right wheel

      // Rotate wheels to simulate rolling
      wheels.forEach(wheel => {
        wheel.rotation.x -= velocity * 20;
      });

      // Camera follow
      const camOffset = new THREE.Vector3(0, 5, -12);
      camOffset.applyAxisAngle(new THREE.Vector3(0,1,0), car.rotation.y);
      camera.position.copy(car.position).add(camOffset);
      camera.lookAt(car.position);
    }

    renderer.render(scene, camera);
  }
</script>
</body>
</html>
